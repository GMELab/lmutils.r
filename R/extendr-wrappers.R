# Generated by extendr: Do not edit by hand

# nolint start

#
# This file was created with the following call:
#   .Call("wrap__make_lmutils_wrappers", use_symbols = TRUE, package_name = "lmutils")

#' @docType package
#' @usage NULL
#' @useDynLib lmutils, .registration = TRUE
NULL

#' Saves a list of matrix convertible objects to a character vector of file names.
#' `from` is a list of matrix convertable objects.
#' `to` is a character vector of file names to write to.
#' @export
save <- function(from, to) .Call(wrap__save, from, to)

#' Recursively converts a directory of files to the selected format.
#' `from` is the directory to read from.
#' `to` is the directory to write to or `NULL` to write to `from`.
#' `file_type` is the file extension to write as.
#' @export
save_dir <- function(from, to, file_type) .Call(wrap__save_dir, from, to, file_type)

#' Calculate R^2 and adjusted R^2 for a block and outcomes.
#' `data` is a list of matrix convertable objects.
#' `outcomes` is a matrix convertable object.
#' Returns a data frame with columns `r2`, `adj_r2`, `data`, `outcome`, `n`, `m`, and `predicted`.
#' @export
calculate_r2 <- function(data, outcomes) .Call(wrap__calculate_r2, data, outcomes)

#' Compute the p value of a linear regression between each pair of columns in two matrices.
#' `data` is a list of matrix convertable objects.
#' `outcomes` is a matrix convertable object.
#' Returns a data frame with columns `p`, `beta`, `intercept`, `data`, `data_column`, and `outcome`.
#' @export
column_p_values <- function(data, outcomes) .Call(wrap__column_p_values, data, outcomes)

#' Compute a linear regression between each matrix in a list and a each column in another matrix.
#' `data` is a list of matrix convertable objects.
#' `outcomes` is a matrix convertable object.
#' Returns a data frame with columns `slopes`, `intercept`, `predicted` (if enabled), `r2`,
#' `adj_r2`, `data`, `outcome`, `n`, and `m`.
#' @export
linear_regression <- function(data, outcomes) .Call(wrap__linear_regression, data, outcomes)

#' Combine a list of double vectors into a matrix.
#' `data` is a list of double vectors.
#' `out` is an output file name or `NULL` to return the matrix.
#' @export
combine_vectors <- function(data, out) .Call(wrap__combine_vectors, data, out)

#' Combine a potentially nested list of rows (double vectors) into a matrix.
#' `data` is a list of lists of double vectors.
#' `out` is an output file name or `NULL` to return the matrix.
#' @export
combine_rows <- function(data, out) .Call(wrap__combine_rows, data, out)

#' Remove rows from a matrix.
#' `data` is a list of matrix convertable objects.
#' `rows` is a vector of row indices to remove (1-based).
#' `out` is a standard output file.
#' @export
remove_rows <- function(data, rows, out) .Call(wrap__remove_rows, data, rows, out)

#' Computes the cross product of the matrix. Equivalent to `t(data) %*% data`.
#' `data` is a list of matrix convertable objects.
#' `out` is a standard output file.
#' @export
crossprod <- function(data, out) .Call(wrap__crossprod, data, out)

#' Multiply two matrices. Equivalent to `a %*% b`.
#' `a` is a list of matrix convertable objects.
#' `b` is a list of matrix convertable objects.
#' `out` is a standard output file.
#' @export
mul <- function(a, b, out) .Call(wrap__mul, a, b, out)

#' Load a matrix convertable object into R.
#' `obj` is a list of matrix convertable objects.
#' If a single object is provided, the function will return the matrix directly, otherwise it will return a list of matrices.
#' @export
load <- function(obj) .Call(wrap__load, obj)

#' Match the rows of a matrix to the values in a vector by a column.
#' `data` is a list of matrix convertable objects.
#' `with` is a numeric vector.
#' `by` is the column to match by.
#' `out` is a standard output file.
#' @export
match_rows <- function(data, with, by, out) .Call(wrap__match_rows, data, with, by, out)

#' Recursively matches the rows of a directory of matrices to the values in a vector by a column.
#' `from` is the directory to read from.
#' `to` is the directory to write to.
#' `with` is a numeric vector.
#' `by` is the column to match by.
#' @export
match_rows_dir <- function(from, to, with, by) .Call(wrap__match_rows_dir, from, to, with, by)

#' Deduplicate a matrix by a column. The first occurrence of each value is kept.
#' `data` is a list of matrix convertable objects.
#' `by` is the column to deduplicate by.
#' `out` is a standard output file.
#' @export
dedup <- function(data, by, out) .Call(wrap__dedup, data, by, out)

#' Compute a new column for a data frame from a regex and an existing column.
#' `df` is a data frame.
#' `column` is the column to match.
#' `regex` is the regex to match. The first capture group is used.
#' `new_column` is the new column name.
#' This function uses the Rust flavor of regex, see https://docs.rs/regex/latest/regex/#syntax for more /* information */.
#' @export
new_column_from_regex <- function(df, column, regex, new_column) .Call(wrap__new_column_from_regex, df, column, regex, new_column)

#' Converts two character vectors into a named list, where the first vector is the names and the second vector is the values. Only the first occurrence of each name is used, essentially creating a map.
#' `names` is a character vector of names.
#' `values` is a character vector of values.
#' @export
map_from_pairs <- function(names, values) .Call(wrap__map_from_pairs, names, values)

#' Compute a new column for a data frame from a list of values and an existing column, matching by the names of the values.
#' `column` is the column to match.
#' `values` is a named list of values.
#' `new_column` is the new column name.
#' @export
new_column_from_map <- function(df, column, values, new_column) .Call(wrap__new_column_from_map, df, column, values, new_column)

#' Compute a new column for a data frame from two character vectors of names and values, matching by the names.
#' `df` is a data frame.
#' `column` is the column to match.
#' `names` is a character vector of names.
#' `values` is a character vector of values.
#' `new_column` is the new column name.
#' @export
new_column_from_map_pairs <- function(df, column, names, values, new_column) .Call(wrap__new_column_from_map_pairs, df, column, names, values, new_column)

#' Mutably sorts a data frame in ascending order by multiple columns in ascending order.
#' `df` is a data frame.
#' `columns` is a character vector of columns to sort by. The sort columns must be numeric
#' (integer or double), character, or logical vectors.
#' @export
df_sort_asc <- function(df, columns) .Call(wrap__df_sort_asc, df, columns)

#' Splits a data frame into multiple data frames by a column. This function will mutably sort the
#' data frame by the column before splitting.
#' `df` is a data frame.
#' `by` is the column to split by. The column must be a numeric (integer or double) or character
#' vector.
#' @export
df_split <- function(df, by) .Call(wrap__df_split, df, by)

#' Combine a potentially nested list of data frames into a single data frame.
#' `data` is a list of lists of data frames.
#' @export
df_combine <- function(data) .Call(wrap__df_combine, data)

#' Compute the R^2 value for given actual and predicted vectors.
#' `actual` is a numeric vector of actual values.
#' `predicted` is a numeric vector of predicted values.
#' @export
compute_r2 <- function(actual, predicted) .Call(wrap__compute_r2, actual, predicted)

#' Compute the mean of a numeric vector.
#' `x` is a numeric vector.
#' @export
mean <- function(x) .Call(wrap__mean, x)

#' Compute the median of a numeric vector.
#' `x` is a numeric vector.
#' @export
median <- function(x) .Call(wrap__median, x)

#' Compute the standard deviation of a numeric vector.
#' `x` is a numeric vector.
#' @export
sd <- function(x) .Call(wrap__sd, x)

#' Compute the variance of a numeric vector.
#' `x` is a numeric vector.
#' @export
var <- function(x) .Call(wrap__var, x)

#' Set the log level.
#' `level` is the log level.
#' @export
set_log_level <- function(level) invisible(.Call(wrap__set_log_level, level))

#' Sets the core parallelism for lmutils.
#' This is the number of primary operations to perform at once.
#' `num` is the number of main threads.
#' @export
set_core_parallelism <- function(num) invisible(.Call(wrap__set_core_parallelism, num))

#' Set the number of worker threads to use. By default this value is `num_cpus::get() / 2`.
#' This is the number of threads to use for parallel operations.
#' `num` is the number of worker threads.
#' @export
set_num_worker_threads <- function(num) invisible(.Call(wrap__set_num_worker_threads, num))

#' Disable the calculation of predicted values in `calculate_r2`.
#' @export
disable_predicted <- function() invisible(.Call(wrap__disable_predicted))

#' Enable the calculation of predicted values in `calculate_r2`.
#' @export
enable_predicted <- function() invisible(.Call(wrap__enable_predicted))

#' Ignore errors in core parallel operations.
#' @export
ignore_core_parallel_errors <- function() invisible(.Call(wrap__ignore_core_parallel_errors))

#' Don't ignore errors in core parallel operations.
#' @export
dont_ignore_core_parallel_errors <- function() invisible(.Call(wrap__dont_ignore_core_parallel_errors))

#' @export
internal_lmutils_fd_into_file <- function(file, fd, libc_2_27) invisible(.Call(wrap__internal_lmutils_fd_into_file, file, fd, libc_2_27))

#' @export
internal_lmutils_file_into_fd <- function(file, fd) invisible(.Call(wrap__internal_lmutils_file_into_fd, file, fd))

#' DEPRECATED
#' Convert files from one format to another.
#' `from` is a list of matrix convertable objects.
#' `to` is a list of file names to write to.
#' @export
convert_file <- function(from, to) .Call(wrap__convert_file, from, to)

#' DEPRECATED
#' Save a matrix to a file.
#' `mat` must be a double matrix.
#' `out` is the name of the file to save to.
#' @export
save_matrix <- function(mat, out) .Call(wrap__save_matrix, mat, out)

#' Standardize a matrix. All NaN values are replaced with the mean of the column and each column is scaled to have a mean of 0 and a standard deviation of 1.
#' `data` is a string file name or a matrix.
#' `out` is a file name to write the normalized matrix to or `NULL` to return the normalized
#' matrix.
#' @export
standardize <- function(data, out) .Call(wrap__standardize, data, out)

#' DEPRECATED
#' Convert a data frame to a file.
#' `df` must be a numeric data frame, numeric matrix, or a string RData file name.
#' `out` is the name of the file to save to.
#' If `out` is `NULL`, the matrix is returned otherwise `NULL`.
#' @export
to_matrix <- function(df, out) .Call(wrap__to_matrix, df, out)

#' DEPRECATED
#' Recursively converts a directory of files to the selected format.
#' `from` is the directory to read from.
#' `to` is the directory to write to.
#' `file_type` is the file extension to write as.
#' If `to` is `NULL`, the files are written to `from`.
#' @export
to_matrix_dir <- function(from, to, file_type) .Call(wrap__to_matrix_dir, from, to, file_type)

#' DEPRECATED
#' Extend matrices into a single matrix by rows.
#' `data` is a character vector of file names or a list of matrices.
#' `out` is a file name to write the combined matrix to.
#' If `out` is `NULL`, the combined matrix is returned otherwise `NULL`.
#' @export
extend_matrices <- function(data, out) .Call(wrap__extend_matrices, data, out)

#' DEPRECATED
#' Set the number of main threads to use.
#' This is the number of primary operations to perform at once.
#' `num` is the number of main threads.
#' @export
set_num_main_threads <- function(num) invisible(.Call(wrap__set_num_main_threads, num))

#' DEPRECATED
#' Combine matrices into a single matrix by columns.
#' `data` is a character vector of file names or a list of matrices.
#' `out` is a file name to write the combined matrix to.
#' If `out` is `NULL`, the combined matrix is returned otherwise `NULL`.
#' @export
combine_matrices <- function(data, out) .Call(wrap__combine_matrices, data, out)

#' DEPRECATED
#' Load a matrix from a file.
#' `file` is the name of the file to load from.
#' @export
load_matrix <- function(file) .Call(wrap__load_matrix, file)

#' `lmutils::Mat` objects are a way to store matrices in memory and perform operations on them. They can be used to store operations or chain operations together for later execution. This can be useful if, for example, you wish to a hundred large matrices from files and standardize them all before using `lmutils::calculate_r2`. Using `Mat` objects, you can store the operations you wish to perform and `Mat` will execute them only when the matrix is loaded.
#' @export
Mat <- new.env(parent = emptyenv())

Mat$new <- function(data) .Call(wrap__Mat__new, data)

Mat$r <- function() .Call(wrap__Mat__r, self)

Mat$col <- function(column) .Call(wrap__Mat__col, self, column)

Mat$colnames <- function() .Call(wrap__Mat__colnames, self)

Mat$save <- function(file) .Call(wrap__Mat__save, self, file)

Mat$combine_columns <- function(data) .Call(wrap__Mat__combine_columns, self, data)

Mat$combine_rows <- function(data) .Call(wrap__Mat__combine_rows, self, data)

Mat$remove_columns <- function(columns) .Call(wrap__Mat__remove_columns, self, columns)

Mat$remove_column <- function(column) .Call(wrap__Mat__remove_column, self, column)

Mat$remove_column_if_exists <- function(column) .Call(wrap__Mat__remove_column_if_exists, self, column)

Mat$remove_rows <- function(rows) .Call(wrap__Mat__remove_rows, self, rows)

Mat$transpose <- function() .Call(wrap__Mat__transpose, self)

Mat$sort <- function(by) .Call(wrap__Mat__sort, self, by)

Mat$sort_by_name <- function(by) .Call(wrap__Mat__sort_by_name, self, by)

Mat$sort_by_order <- function(order) .Call(wrap__Mat__sort_by_order, self, order)

Mat$dedup <- function(by) .Call(wrap__Mat__dedup, self, by)

Mat$dedup_by_name <- function(by) .Call(wrap__Mat__dedup_by_name, self, by)

Mat$match_to <- function(with, by, join) .Call(wrap__Mat__match_to, self, with, by, join)

Mat$match_to_by_name <- function(with, by, join) .Call(wrap__Mat__match_to_by_name, self, with, by, join)

Mat$join <- function(other, self_by, other_by, join) .Call(wrap__Mat__join, self, other, self_by, other_by, join)

Mat$join_by_name <- function(other, by, join) .Call(wrap__Mat__join_by_name, self, other, by, join)

Mat$standardize_columns <- function() .Call(wrap__Mat__standardize_columns, self)

Mat$standardize_rows <- function() .Call(wrap__Mat__standardize_rows, self)

Mat$remove_na_rows <- function() .Call(wrap__Mat__remove_na_rows, self)

Mat$remove_na_columns <- function() .Call(wrap__Mat__remove_na_columns, self)

Mat$na_to_value <- function(value) .Call(wrap__Mat__na_to_value, self, value)

Mat$na_to_column_mean <- function() .Call(wrap__Mat__na_to_column_mean, self)

Mat$na_to_row_mean <- function() .Call(wrap__Mat__na_to_row_mean, self)

Mat$min_column_sum <- function(value) .Call(wrap__Mat__min_column_sum, self, value)

Mat$max_column_sum <- function(value) .Call(wrap__Mat__max_column_sum, self, value)

Mat$min_row_sum <- function(value) .Call(wrap__Mat__min_row_sum, self, value)

Mat$max_row_sum <- function(value) .Call(wrap__Mat__max_row_sum, self, value)

Mat$rename_column <- function(old, new) .Call(wrap__Mat__rename_column, self, old, new)

Mat$rename_column_if_exists <- function(old, new) .Call(wrap__Mat__rename_column_if_exists, self, old, new)

Mat$remove_duplicate_columns <- function() .Call(wrap__Mat__remove_duplicate_columns, self)

Mat$remove_identical_columns <- function() .Call(wrap__Mat__remove_identical_columns, self)

Mat$subset_columns <- function(columns) .Call(wrap__Mat__subset_columns, self, columns)

#' @rdname Mat
#' @usage NULL
#' @export
`$.Mat` <- function (self, name) { func <- Mat[[name]]; environment(func) <- environment(); func }

#' @export
`[[.Mat` <- `$.Mat`


# nolint end
